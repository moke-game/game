//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

package cfg

import "errors"

type PlaySelect struct {
	ID            int32
	Name          string
	Info          string
	UnderlayColor string
	Res           string
	Display       int32
	BattleMode    int32
	Gameplay      string
	GameTime      int32
	MapID         []int32
	MapWeight     []int32
	MatchType     int32
	Team          int32
	Member        int32
	Rebirth       int32
	RebirthBuff   []int32
	ReviveTimes   int32
	ReviveWait    int32
	Mode          int32
	Rewards1      []*ItemReward
	Rewards2      []*ItemReward
	Rewards3      []*BattleSpecialReward
	RewardsMatch  []*ItemReward
	RewardsMvp    []*ItemReward
	WinPoint      int32
	MVPRule       int32
	Extratime     int32
	IntTime       int32
	GameplayBuff  []int32
	BeginTime     string
	EndTime       string
	FeatureID     int32
	BotBehavior   []int32
	RevailConsume []*ItemReward
}

const TypeId_PlaySelect = -732278416

func (*PlaySelect) GetTypeId() int32 {
	return -732278416
}

func (_v *PlaySelect) Deserialize(_buf map[string]interface{}) (err error) {
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["ID"].(float64); !_ok_ {
			err = errors.New("ID error")
			return
		}
		_v.ID = int32(_tempNum_)
	}
	{
		var _ok_ bool
		if _v.Name, _ok_ = _buf["Name"].(string); !_ok_ {
			err = errors.New("Name error")
			return
		}
	}
	{
		var _ok_ bool
		if _v.Info, _ok_ = _buf["Info"].(string); !_ok_ {
			err = errors.New("Info error")
			return
		}
	}
	{
		var _ok_ bool
		if _v.UnderlayColor, _ok_ = _buf["UnderlayColor"].(string); !_ok_ {
			err = errors.New("UnderlayColor error")
			return
		}
	}
	{
		var _ok_ bool
		if _v.Res, _ok_ = _buf["Res"].(string); !_ok_ {
			err = errors.New("Res error")
			return
		}
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["Display"].(float64); !_ok_ {
			err = errors.New("Display error")
			return
		}
		_v.Display = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["BattleMode"].(float64); !_ok_ {
			err = errors.New("BattleMode error")
			return
		}
		_v.BattleMode = int32(_tempNum_)
	}
	{
		var _ok_ bool
		if _v.Gameplay, _ok_ = _buf["Gameplay"].(string); !_ok_ {
			err = errors.New("Gameplay error")
			return
		}
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["GameTime"].(float64); !_ok_ {
			err = errors.New("GameTime error")
			return
		}
		_v.GameTime = int32(_tempNum_)
	}
	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["MapID"].([]interface{}); !_ok_ {
			err = errors.New("MapID error")
			return
		}

		_v.MapID = make([]int32, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ int32
			{
				var _ok_ bool
				var _x_ float64
				if _x_, _ok_ = _e_.(float64); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				_list_v_ = int32(_x_)
			}
			_v.MapID = append(_v.MapID, _list_v_)
		}
	}

	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["MapWeight"].([]interface{}); !_ok_ {
			err = errors.New("MapWeight error")
			return
		}

		_v.MapWeight = make([]int32, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ int32
			{
				var _ok_ bool
				var _x_ float64
				if _x_, _ok_ = _e_.(float64); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				_list_v_ = int32(_x_)
			}
			_v.MapWeight = append(_v.MapWeight, _list_v_)
		}
	}

	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["MatchType"].(float64); !_ok_ {
			err = errors.New("MatchType error")
			return
		}
		_v.MatchType = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["Team"].(float64); !_ok_ {
			err = errors.New("Team error")
			return
		}
		_v.Team = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["Member"].(float64); !_ok_ {
			err = errors.New("Member error")
			return
		}
		_v.Member = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["Rebirth"].(float64); !_ok_ {
			err = errors.New("Rebirth error")
			return
		}
		_v.Rebirth = int32(_tempNum_)
	}
	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["RebirthBuff"].([]interface{}); !_ok_ {
			err = errors.New("RebirthBuff error")
			return
		}

		_v.RebirthBuff = make([]int32, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ int32
			{
				var _ok_ bool
				var _x_ float64
				if _x_, _ok_ = _e_.(float64); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				_list_v_ = int32(_x_)
			}
			_v.RebirthBuff = append(_v.RebirthBuff, _list_v_)
		}
	}

	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["ReviveTimes"].(float64); !_ok_ {
			err = errors.New("ReviveTimes error")
			return
		}
		_v.ReviveTimes = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["ReviveWait"].(float64); !_ok_ {
			err = errors.New("ReviveWait error")
			return
		}
		_v.ReviveWait = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["Mode"].(float64); !_ok_ {
			err = errors.New("Mode error")
			return
		}
		_v.Mode = int32(_tempNum_)
	}
	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["Rewards1"].([]interface{}); !_ok_ {
			err = errors.New("Rewards1 error")
			return
		}

		_v.Rewards1 = make([]*ItemReward, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ *ItemReward
			{
				var _ok_ bool
				var _x_ map[string]interface{}
				if _x_, _ok_ = _e_.(map[string]interface{}); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				if _list_v_, err = DeserializeItemReward(_x_); err != nil {
					return
				}
			}
			_v.Rewards1 = append(_v.Rewards1, _list_v_)
		}
	}

	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["Rewards2"].([]interface{}); !_ok_ {
			err = errors.New("Rewards2 error")
			return
		}

		_v.Rewards2 = make([]*ItemReward, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ *ItemReward
			{
				var _ok_ bool
				var _x_ map[string]interface{}
				if _x_, _ok_ = _e_.(map[string]interface{}); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				if _list_v_, err = DeserializeItemReward(_x_); err != nil {
					return
				}
			}
			_v.Rewards2 = append(_v.Rewards2, _list_v_)
		}
	}

	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["Rewards3"].([]interface{}); !_ok_ {
			err = errors.New("Rewards3 error")
			return
		}

		_v.Rewards3 = make([]*BattleSpecialReward, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ *BattleSpecialReward
			{
				var _ok_ bool
				var _x_ map[string]interface{}
				if _x_, _ok_ = _e_.(map[string]interface{}); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				if _list_v_, err = DeserializeBattleSpecialReward(_x_); err != nil {
					return
				}
			}
			_v.Rewards3 = append(_v.Rewards3, _list_v_)
		}
	}

	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["RewardsMatch"].([]interface{}); !_ok_ {
			err = errors.New("RewardsMatch error")
			return
		}

		_v.RewardsMatch = make([]*ItemReward, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ *ItemReward
			{
				var _ok_ bool
				var _x_ map[string]interface{}
				if _x_, _ok_ = _e_.(map[string]interface{}); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				if _list_v_, err = DeserializeItemReward(_x_); err != nil {
					return
				}
			}
			_v.RewardsMatch = append(_v.RewardsMatch, _list_v_)
		}
	}

	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["RewardsMvp"].([]interface{}); !_ok_ {
			err = errors.New("RewardsMvp error")
			return
		}

		_v.RewardsMvp = make([]*ItemReward, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ *ItemReward
			{
				var _ok_ bool
				var _x_ map[string]interface{}
				if _x_, _ok_ = _e_.(map[string]interface{}); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				if _list_v_, err = DeserializeItemReward(_x_); err != nil {
					return
				}
			}
			_v.RewardsMvp = append(_v.RewardsMvp, _list_v_)
		}
	}

	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["WinPoint"].(float64); !_ok_ {
			err = errors.New("WinPoint error")
			return
		}
		_v.WinPoint = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["MVPRule"].(float64); !_ok_ {
			err = errors.New("MVPRule error")
			return
		}
		_v.MVPRule = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["Extratime"].(float64); !_ok_ {
			err = errors.New("Extratime error")
			return
		}
		_v.Extratime = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["IntTime"].(float64); !_ok_ {
			err = errors.New("IntTime error")
			return
		}
		_v.IntTime = int32(_tempNum_)
	}
	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["GameplayBuff"].([]interface{}); !_ok_ {
			err = errors.New("GameplayBuff error")
			return
		}

		_v.GameplayBuff = make([]int32, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ int32
			{
				var _ok_ bool
				var _x_ float64
				if _x_, _ok_ = _e_.(float64); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				_list_v_ = int32(_x_)
			}
			_v.GameplayBuff = append(_v.GameplayBuff, _list_v_)
		}
	}

	{
		var _ok_ bool
		if _v.BeginTime, _ok_ = _buf["BeginTime"].(string); !_ok_ {
			err = errors.New("BeginTime error")
			return
		}
	}
	{
		var _ok_ bool
		if _v.EndTime, _ok_ = _buf["EndTime"].(string); !_ok_ {
			err = errors.New("EndTime error")
			return
		}
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["FeatureID"].(float64); !_ok_ {
			err = errors.New("FeatureID error")
			return
		}
		_v.FeatureID = int32(_tempNum_)
	}
	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["BotBehavior"].([]interface{}); !_ok_ {
			err = errors.New("BotBehavior error")
			return
		}

		_v.BotBehavior = make([]int32, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ int32
			{
				var _ok_ bool
				var _x_ float64
				if _x_, _ok_ = _e_.(float64); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				_list_v_ = int32(_x_)
			}
			_v.BotBehavior = append(_v.BotBehavior, _list_v_)
		}
	}

	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["RevailConsume"].([]interface{}); !_ok_ {
			err = errors.New("RevailConsume error")
			return
		}

		_v.RevailConsume = make([]*ItemReward, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ *ItemReward
			{
				var _ok_ bool
				var _x_ map[string]interface{}
				if _x_, _ok_ = _e_.(map[string]interface{}); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				if _list_v_, err = DeserializeItemReward(_x_); err != nil {
					return
				}
			}
			_v.RevailConsume = append(_v.RevailConsume, _list_v_)
		}
	}

	return
}

func DeserializePlaySelect(_buf map[string]interface{}) (*PlaySelect, error) {
	v := &PlaySelect{}
	if err := v.Deserialize(_buf); err == nil {
		return v, nil
	} else {
		return nil, err
	}
}
