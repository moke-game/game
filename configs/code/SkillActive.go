//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

package cfg

import "errors"

type SkillActive struct {
	ID             int32
	Name           string
	Describe       string
	Icon           string
	Clip           int32
	CD             int32
	CDDelay        int32
	PreStart       int32
	FireWarning    int32
	PrepareTime    int32
	PreDuration    int32
	PreState       []int32
	StateBuff      []int32
	BuffSelf       []int32
	SelfBuffHit    []int32
	IsTargetMark   int32
	IsSuspendMark  int32
	SkillType      []int32
	AutoLock       int32
	ChooseMark     int32
	RestockMark    int32
	ShowRange      int32
	Range          []int32
	RangeSpeed     int32
	SkillEffect    []int32
	EffectTime     []int32
	Condition      int32
	Distance       int32
	MoveTime       []int32
	JumpRes        string
	JumpDel        int32
	HangRes        string
	HangBone       int32
	CameraSet      []int32
	AiType         []int32
	BuffConsume    int32
	IsInterrupt    int32
	TriggerAction  []*SkillsTriggerAction
	SkillLogicType int32
}

const TypeId_SkillActive = -912384873

func (*SkillActive) GetTypeId() int32 {
	return -912384873
}

func (_v *SkillActive) Deserialize(_buf map[string]interface{}) (err error) {
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["ID"].(float64); !_ok_ {
			err = errors.New("ID error")
			return
		}
		_v.ID = int32(_tempNum_)
	}
	{
		var _ok_ bool
		if _v.Name, _ok_ = _buf["Name"].(string); !_ok_ {
			err = errors.New("Name error")
			return
		}
	}
	{
		var _ok_ bool
		if _v.Describe, _ok_ = _buf["Describe"].(string); !_ok_ {
			err = errors.New("Describe error")
			return
		}
	}
	{
		var _ok_ bool
		if _v.Icon, _ok_ = _buf["Icon"].(string); !_ok_ {
			err = errors.New("Icon error")
			return
		}
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["Clip"].(float64); !_ok_ {
			err = errors.New("Clip error")
			return
		}
		_v.Clip = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["CD"].(float64); !_ok_ {
			err = errors.New("CD error")
			return
		}
		_v.CD = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["CDDelay"].(float64); !_ok_ {
			err = errors.New("CDDelay error")
			return
		}
		_v.CDDelay = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["PreStart"].(float64); !_ok_ {
			err = errors.New("PreStart error")
			return
		}
		_v.PreStart = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["FireWarning"].(float64); !_ok_ {
			err = errors.New("FireWarning error")
			return
		}
		_v.FireWarning = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["PrepareTime"].(float64); !_ok_ {
			err = errors.New("PrepareTime error")
			return
		}
		_v.PrepareTime = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["PreDuration"].(float64); !_ok_ {
			err = errors.New("PreDuration error")
			return
		}
		_v.PreDuration = int32(_tempNum_)
	}
	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["PreState"].([]interface{}); !_ok_ {
			err = errors.New("PreState error")
			return
		}

		_v.PreState = make([]int32, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ int32
			{
				var _ok_ bool
				var _x_ float64
				if _x_, _ok_ = _e_.(float64); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				_list_v_ = int32(_x_)
			}
			_v.PreState = append(_v.PreState, _list_v_)
		}
	}

	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["StateBuff"].([]interface{}); !_ok_ {
			err = errors.New("StateBuff error")
			return
		}

		_v.StateBuff = make([]int32, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ int32
			{
				var _ok_ bool
				var _x_ float64
				if _x_, _ok_ = _e_.(float64); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				_list_v_ = int32(_x_)
			}
			_v.StateBuff = append(_v.StateBuff, _list_v_)
		}
	}

	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["BuffSelf"].([]interface{}); !_ok_ {
			err = errors.New("BuffSelf error")
			return
		}

		_v.BuffSelf = make([]int32, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ int32
			{
				var _ok_ bool
				var _x_ float64
				if _x_, _ok_ = _e_.(float64); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				_list_v_ = int32(_x_)
			}
			_v.BuffSelf = append(_v.BuffSelf, _list_v_)
		}
	}

	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["SelfBuffHit"].([]interface{}); !_ok_ {
			err = errors.New("SelfBuffHit error")
			return
		}

		_v.SelfBuffHit = make([]int32, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ int32
			{
				var _ok_ bool
				var _x_ float64
				if _x_, _ok_ = _e_.(float64); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				_list_v_ = int32(_x_)
			}
			_v.SelfBuffHit = append(_v.SelfBuffHit, _list_v_)
		}
	}

	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["IsTargetMark"].(float64); !_ok_ {
			err = errors.New("IsTargetMark error")
			return
		}
		_v.IsTargetMark = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["IsSuspendMark"].(float64); !_ok_ {
			err = errors.New("IsSuspendMark error")
			return
		}
		_v.IsSuspendMark = int32(_tempNum_)
	}
	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["SkillType"].([]interface{}); !_ok_ {
			err = errors.New("SkillType error")
			return
		}

		_v.SkillType = make([]int32, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ int32
			{
				var _ok_ bool
				var _x_ float64
				if _x_, _ok_ = _e_.(float64); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				_list_v_ = int32(_x_)
			}
			_v.SkillType = append(_v.SkillType, _list_v_)
		}
	}

	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["AutoLock"].(float64); !_ok_ {
			err = errors.New("AutoLock error")
			return
		}
		_v.AutoLock = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["ChooseMark"].(float64); !_ok_ {
			err = errors.New("ChooseMark error")
			return
		}
		_v.ChooseMark = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["RestockMark"].(float64); !_ok_ {
			err = errors.New("RestockMark error")
			return
		}
		_v.RestockMark = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["ShowRange"].(float64); !_ok_ {
			err = errors.New("ShowRange error")
			return
		}
		_v.ShowRange = int32(_tempNum_)
	}
	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["Range"].([]interface{}); !_ok_ {
			err = errors.New("Range error")
			return
		}

		_v.Range = make([]int32, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ int32
			{
				var _ok_ bool
				var _x_ float64
				if _x_, _ok_ = _e_.(float64); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				_list_v_ = int32(_x_)
			}
			_v.Range = append(_v.Range, _list_v_)
		}
	}

	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["RangeSpeed"].(float64); !_ok_ {
			err = errors.New("RangeSpeed error")
			return
		}
		_v.RangeSpeed = int32(_tempNum_)
	}
	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["SkillEffect"].([]interface{}); !_ok_ {
			err = errors.New("SkillEffect error")
			return
		}

		_v.SkillEffect = make([]int32, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ int32
			{
				var _ok_ bool
				var _x_ float64
				if _x_, _ok_ = _e_.(float64); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				_list_v_ = int32(_x_)
			}
			_v.SkillEffect = append(_v.SkillEffect, _list_v_)
		}
	}

	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["EffectTime"].([]interface{}); !_ok_ {
			err = errors.New("EffectTime error")
			return
		}

		_v.EffectTime = make([]int32, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ int32
			{
				var _ok_ bool
				var _x_ float64
				if _x_, _ok_ = _e_.(float64); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				_list_v_ = int32(_x_)
			}
			_v.EffectTime = append(_v.EffectTime, _list_v_)
		}
	}

	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["Condition"].(float64); !_ok_ {
			err = errors.New("Condition error")
			return
		}
		_v.Condition = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["Distance"].(float64); !_ok_ {
			err = errors.New("Distance error")
			return
		}
		_v.Distance = int32(_tempNum_)
	}
	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["MoveTime"].([]interface{}); !_ok_ {
			err = errors.New("MoveTime error")
			return
		}

		_v.MoveTime = make([]int32, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ int32
			{
				var _ok_ bool
				var _x_ float64
				if _x_, _ok_ = _e_.(float64); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				_list_v_ = int32(_x_)
			}
			_v.MoveTime = append(_v.MoveTime, _list_v_)
		}
	}

	{
		var _ok_ bool
		if _v.JumpRes, _ok_ = _buf["JumpRes"].(string); !_ok_ {
			err = errors.New("JumpRes error")
			return
		}
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["JumpDel"].(float64); !_ok_ {
			err = errors.New("JumpDel error")
			return
		}
		_v.JumpDel = int32(_tempNum_)
	}
	{
		var _ok_ bool
		if _v.HangRes, _ok_ = _buf["HangRes"].(string); !_ok_ {
			err = errors.New("HangRes error")
			return
		}
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["HangBone"].(float64); !_ok_ {
			err = errors.New("HangBone error")
			return
		}
		_v.HangBone = int32(_tempNum_)
	}
	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["CameraSet"].([]interface{}); !_ok_ {
			err = errors.New("CameraSet error")
			return
		}

		_v.CameraSet = make([]int32, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ int32
			{
				var _ok_ bool
				var _x_ float64
				if _x_, _ok_ = _e_.(float64); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				_list_v_ = int32(_x_)
			}
			_v.CameraSet = append(_v.CameraSet, _list_v_)
		}
	}

	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["AiType"].([]interface{}); !_ok_ {
			err = errors.New("AiType error")
			return
		}

		_v.AiType = make([]int32, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ int32
			{
				var _ok_ bool
				var _x_ float64
				if _x_, _ok_ = _e_.(float64); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				_list_v_ = int32(_x_)
			}
			_v.AiType = append(_v.AiType, _list_v_)
		}
	}

	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["BuffConsume"].(float64); !_ok_ {
			err = errors.New("BuffConsume error")
			return
		}
		_v.BuffConsume = int32(_tempNum_)
	}
	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["IsInterrupt"].(float64); !_ok_ {
			err = errors.New("IsInterrupt error")
			return
		}
		_v.IsInterrupt = int32(_tempNum_)
	}
	{
		var _arr_ []interface{}
		var _ok_ bool
		if _arr_, _ok_ = _buf["TriggerAction"].([]interface{}); !_ok_ {
			err = errors.New("TriggerAction error")
			return
		}

		_v.TriggerAction = make([]*SkillsTriggerAction, 0, len(_arr_))

		for _, _e_ := range _arr_ {
			var _list_v_ *SkillsTriggerAction
			{
				var _ok_ bool
				var _x_ map[string]interface{}
				if _x_, _ok_ = _e_.(map[string]interface{}); !_ok_ {
					err = errors.New("_list_v_ error")
					return
				}
				if _list_v_, err = DeserializeSkillsTriggerAction(_x_); err != nil {
					return
				}
			}
			_v.TriggerAction = append(_v.TriggerAction, _list_v_)
		}
	}

	{
		var _ok_ bool
		var _tempNum_ float64
		if _tempNum_, _ok_ = _buf["SkillLogicType"].(float64); !_ok_ {
			err = errors.New("SkillLogicType error")
			return
		}
		_v.SkillLogicType = int32(_tempNum_)
	}
	return
}

func DeserializeSkillActive(_buf map[string]interface{}) (*SkillActive, error) {
	v := &SkillActive{}
	if err := v.Deserialize(_buf); err == nil {
		return v, nil
	} else {
		return nil, err
	}
}
